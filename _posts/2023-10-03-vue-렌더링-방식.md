---
layout: post
title:  "vue 렌더링 방식 (작동 원리)"
date:   2023-10-03 09:00:00 +0900
author: ejsin
categories: vue
---
<hr/>

원래 react를 사용하다 vue로 넘어오게 되었습니다.

리액트의 작동 방식, 렌더링 방식을 본 적이 있는데 

뷰는 어떨지 궁금해 찾아보게 되었습니다.

# Vue 렌더링 방식

먼저 공식문서에 있는 그림입니다.

![vue_rendering_mechanism.png](/assets/images/ejsin/vue_rendering_mechanism.png)

하나씩 보겠습니다.

## Template

```
<template>
  <article class='my-data-container'>
    <div>
      <h1 class='my-data-hub-h1'>
        마이 데이터 허브
      </h1>
      <section class='my-data-hub-box my-data-content'>
        <MyDataHubNav />
        <router-view :key='$route.fullPath'/>
      </section>
    </div>
  </article>
</template>
```

뷰로 UI를 그릴때는 위처럼 html 문법으로 템플릿을 만듭니다.

그러면 뷰는 템플릿을 컴파일해서 render function을 만듭니다.

## Render Function

```
render(h) {
  return h('article', { class: 'my-data-container' }, [
    h('div', {}, [
      h('h1', { class: 'my-data-hub-h1' }, '마이 데이터 허브'),
      h('section', { class: 'my-data-hub-box my-data-content' }, [
        h(MyDataHubNav),
        h('router-view', { key: this.$route.fullPath })
      ])
    ])
  ]);
}
```

(Vue Template Explorer 참고용)
![render_function_example.png](/assets/images/ejsin/render_function_example.png)

node의 많은 정보를 담고있어서 상당히 복잡한 함수가 나옵니다.

vue2 에서는 위 h (createElement)를 파라미터로 받아와 사용하지만 

vue3 에서는 import { h } from 'vue' 로 바로 h 를 사용합니다.

참고로 h 는 하이퍼스크립트(hyperscript)의 약자라고 합니다.

아무튼 위 리턴값으로 가상 DOM을 반환합니다.

### Render Function 과정을 거치는 이유

- 일관성 유지

뷰는 템플릿 말고도 jsx나 render method를 통해서 컴포넌트를 만들 수 있는데

어떤 방식을 쓰든 렌더 함수를 거쳐서 가상 DOM 을 반환하도록 만들어 내부 메커니즘의

일관성을 유지합니다.

- 최적화

컴포넌트의 정적인 부분을 캐시해 최적화 기능을 만듭니다.

### Render Function 을 써야하는 경우

선언적으로 동적 컴포넌트를 사용하기 힘들때

```
export default class Test extends Vue {
  tmp = 3

  render(h) {
    let element = h('div', 'test');

    for (let i = 0; i < this.tmp; i++) {
      element = h('div', [element]);
    }
    return element;
  }
}
```

```
<div>
  <div>
    <div>
      test
    </div>
  </div>
</div>
```

위 예시처럼 중첩(nesting) 태그를 사용할 때 렌더 함수를 써야 합니다.

## Virtual DOM

```
{
  tag: 'article',
  data: {
    class: 'my-data-container'
  },
  children: [
    {
      tag: 'div',
      data: {},
      children: [
        {
          tag: 'h1',
          data: {
            class: 'my-data-hub-h1'
          },
          text: '마이 데이터 허브'
        },
        {
          tag: 'section',
          data: {
            class: 'my-data-hub-box my-data-content'
          },
          children: [
            {
              tag: 'MyDataHubNav',
              data: {}
            },
            {
              tag: 'router-view',
              data: {
                key: this.$route.fullPath
              }
            }
          ]
        }
      ]
    }
  ]
}
```

가상 DOM은 리액트나 뷰에서 효율적인 DOM 업데이트를 위해 사용하는 방법(패턴)이며

워낙 자료도 많고 또 자세히 파헤치려면 내용이 많아서 한마디로 요약하자면

'js 객체' 라고 보시면 됩니다.

이 가상 DOM을 가지고 뷰는 실제 DOM에 적용하여 렌더링을 합니다.

## Vue와 가상 DOM

가상 DOM은 유연성, 크로스 플랫폼, 선언적 UI, 최적화 등 여러가지 이유로 사용됩니다.

하지만 문제 있는데, 가상 DOM 에서 업데이트가 일어나면 업데이트가 일어나기전 가상 DOM과 비교하여

**업데이트 된 부분만**을 찾아야 하는데 완전탐색을 통해 업데이트 된 부분 하나하나를

찾는 방법은 너무 비효율적이라 뷰는 **Compiler-Informed Virtual DOM** 라는 

접근 방식을 통해 가상 DOM 의 성능을 향상시킵니다.